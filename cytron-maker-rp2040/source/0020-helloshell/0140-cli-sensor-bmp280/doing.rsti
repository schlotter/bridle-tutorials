Durchführung
************

Hole deinen **Terminalemulator** in den Vordergrund und **stelle sicher**,
das du nach einem Reset (``RST`` Taste kurz gedrückt), folgendes siehst:

.. parsed-literal::
   :class: code

   \*\*\*\*\* delaying boot 4000ms (per build configuration) \*\*\*\*\*
   [00:00:00.179,000] :byl:`<wrn> udc_rpi: BUS RESET`
   [00:00:00.267,000] :byl:`<wrn> udc_rpi: BUS RESET`
   \*\*\* Booting Zephyr OS build zephyr-v3.6… (delayed boot 4000ms) \*\*\*
   Hello World! I'm THE SHELL from |BOARD|
   :bgn:`uart:~$` _

-----------------------------------------------------------------------------

.. ..... ACTION .............................................................

.. image:: /_images/symbol-doing-vi.*
   :class: sidecar

.. compound::

   Schauen wir uns zunächst den Syntax des Kommando :bcy:`sensor` an. Gib ein::

      sensor -h

-----------------------------------------------------------------------------

.. ..... RESULT .............................................................

.. image:: /_images/symbol-observe-or.*
   :class: sidecar

.. compound::

   :ign:`Folgendes wird erscheinen:`

   .. parsed-literal::
      :class: code

      sensor - Sensor commands
      Subcommands:
        get       : Get sensor data. Channel names are optional. All channels are
                    read when no channels are provided. Syntax:
                    <device_name> <channel name 0> .. <channel name N>
        attr_set  : Set the sensor's channel attribute.
                    <device_name> <channel_name> <attribute_name> <value>
        attr_get  : Get the sensor's channel attribute. Syntax:
                    <device_name> [<channel_name 0> <attribute_name 0> ..
                                   <channel_name N> <attribute_name N>]
        info      : Get all sensor info, such as vendor and model name.
        trig      : Get or set the trigger type on a sensor.
                    Currently only supports `data_ready`.
                    <device_name> <on/off> <trigger_name>

.. rubric:: Bestandsaufnahme:

Lass uns zu Beginn gemeinsam überprüfen, ob die aktuelle Zephyr UF2 Firmware
überhaupt in der Lage ist, über die Zephyr Sensor API mit bekannten Sensoren
arbeiten zu können.

-----------------------------------------------------------------------------

.. ..... ACTION .............................................................

.. image:: /_images/symbol-doing-vi.*
   :class: sidecar

.. compound::

   Dafür hilft das Unterkommando :bcy:`sensor info`.
   Gib folgendes ein und beobachte::

      sensor info

-----------------------------------------------------------------------------

.. ..... RESULT .............................................................

.. image:: /_images/symbol-observe-or.*
   :class: sidecar

**ES DARF NICHTS PASSIEREN** – deine aktuelle Zephyr UF2 Firmware, mit der
Zephyr Shell, kennt nicht einen einzigen Sensor.

.. rst-class:: page-break

Extra Devicetree Overlay für deinen BMP280
==========================================

Du musst jetzt ein spezielles :ref:`Devicetree Overlay <zephyr:use-dt-overlays>`
schreiben. Dieses deklariert, dass an deinem I²C Bus der **Drucksensor BMP280**
mit der 7-bit I²C Adresse ``0x77`` angeschlossen ist. Danach wird die Zephyr UF2
Firmware neu gebaut.

-----------------------------------------------------------------------------

.. ..... EDIT ...............................................................

.. image:: /_images/symbol-coder-server-bl.*
   :class: sidecar

.. compound::

   Hole deine **Online-Sitzung von VS Code** in den Vordergrund
   und lege dir direkt in deinem West Workspace die neue Datei
   :file:`grove_i2c-bmp280@77.overlay` an und fülle diese mit
   folgendem Inhalt:

   .. literalinclude:: /_assets/grove_i2c-bmp280@77.overlay
      :language: DTS
      :lines: 6,7,10-

.. rubric:: Eine kurze Erläuterung dazu:

Der I²C Bus wird dir als **Devicetree Node** :devicetree:`&grove_i2c` durch
dein MCU-Board *Cytron – Maker Pi RP2040* zugänglich gemacht. Du erkennst
schnell die Logik eines Devicetree. In genau diesen *"I²C Bus Block"* legst
du nun einen **eigenen Devicetree Node**, den :devicetree:`bmp280: bmp280@77
{ /* … /* };`. Damit gibt es einen neuen Knoten mit dem global ein-eindeutigen
Namen ``bmp280@77`` und der zugehörigen Referenz :devicetree:`&bmp280`. Ein
Knoten ist also nichts weiter als eine eigenständige Komponente *"im großen
Baum deiner Hardware"*.

Das **Pattern mit** ``@77`` **im Namen** und der **Devicetree Property**
:devicetree:`reg = <0x77>;` ist eine **strikte und allgemeingültige Vorgabe**
aus der *Devicetree Spezifikation* \ [#]_ und muss immer dann angewandt werden,
**wenn Ressourcen an feste Addressierungen in der Hardware gebunden sind**,
z.B. auch von einfachen Registern im Speicher (Memory Mapped I/O) oder Chip-\
Select-Leitungen an einem SPI Bus. Hier ist es die **7-bit I²C Adresse des
Sensors am I²C Bus**.

Die **Devicetree Property** :devicetree:`compatible = "bosch,bme280";` sorgt
später beim Erstellen der neuen Zephyr UF2 Firmware, dass **der zugehörige
Sensor-Treiber für den BMP280 vollautomatisch mit eingebunden wird**. Ja, du
ließt es richtig. Im Grunde wird der BM\ **P**\ 280 durch den Treiber seines
teureren größeren Bruders, dem BM\ **E**\ 280, bereitgestellt. **Laut
Datenblatt**\ [#]_ **des Herstellers fehlt dem BMP280 nur der Sensor-Kanal
für die Feuchtigkeit!**

Die **Devicetree Property** :devicetree:`friendly-name = "air pressure";` ist
optional und rein informativ, sollte einmal deine eigene individuelle Zephyr
Applikation Werte aus verschiedenen Sensoren als USB Gerät der Klasse HID an
einen Host-PC liefern wollen. Diese Eigenschaft ist in der Spezifikation
*"Generic Sensor Property Usages of the HID Usage Tables"*\ [#]_
(Abschnitt 22.5) definiert.

.. rst-class:: page-break

Zephyr UF2 Firmware mit extra Devicetree Overlay bauen und laden
================================================================

Hole deine **Online-Sitzung von VS Code** wieder in den Vordergrund.

-----------------------------------------------------------------------------

.. ..... BUILD ..............................................................

.. image:: /_images/symbol-coder-server-bl.*
   :class: sidecar

.. compound::

   **Baue die Zephyr UF2 Firmware** ``helloshell`` **nun aber mit deinem
   zusätzlichen Devicetree Overlay** :file:`grove_i2c-bmp280@77.overlay`,
   gib ein:

   .. parsed-literal::
      :class: code

      west build -p -b |BOARD|        -S usb-console \\
                 bridle/samples/helloshell                          \\
              **-- -DEXTRA_DTC_OVERLAY_FILE=$(pwd)/grove_i2c-bmp280@77.overlay**

-----------------------------------------------------------------------------

.. ..... FLASH ..............................................................

.. image:: /_images/symbol-rp2040-uf2-rd.*
   :class: sidecar

**Lade** dir die **Zephyr UF2 Firmware** herunter und lade diese anschließend
**auf dein MCU-Board**.

Neue Zephyr UF2 Firmware mit extra Devicetree Overlay benutzen
==============================================================

Hole deinen **Terminalemulator** in den Vordergrund.

-----------------------------------------------------------------------------

.. ..... RESULT .............................................................

.. image:: /_images/symbol-observe-or.*
   :class: sidecar

.. compound::

   **Beobachte die Ausgaben**, folgendes muss zu sehen sein:

   .. parsed-literal::
      :class: code

      \*\*\*\*\* delaying boot 4000ms (per build configuration) \*\*\*\*\*
      [00:00:00.189,000] :yl:`<wrn> udc_rpi: BUS RESET`
      [00:00:00.269,000] :yl:`<wrn> udc_rpi: BUS RESET`
      \*\*\* Booting Zephyr OS build zephyr-v3.6… (delayed boot 4000ms) \*\*\*
      Hello World! I'm THE SHELL from |BOARD|
      uart:~$ _

.. ..... INFO ...............................................................

.. admonition:: Gut zu wissen
   :class: good-to-know info

   Erinnere dich an die ersten Übungen mit der Zephyr Shell und der integrierten
   Hilfe. Du solltest jetzt extensiv die Tabulatortaste :kbd:`⇥` benutzen. Die
   Zephyr Shell besitzt in deiner aktuell laufenden Firmware eine eingebaute
   **Command-line TAB-Completion** – wie nützlich, oder?

.. rst-class:: page-break

-----------------------------------------------------------------------------

.. ..... ACTION .............................................................

.. image:: /_images/symbol-doing-vi.*
   :class: sidecar

.. compound::

   Wiederholen wir die Eingabe des Unterkommandos :bcy:`sensor info` von
   vorhin. Gib folgendes ein und beobachte::

      sensor info

-----------------------------------------------------------------------------

.. ..... RESULT .............................................................

.. image:: /_images/symbol-observe-or.*
   :class: sidecar

.. compound::

   :ign:`Folgendes wird erscheinen (in einer einzigen Zeile pro Sensor):`

   .. parsed-literal::
      :class: code

        device name: bmp280@77,
             vendor: Bosch Sensortec GmbH,
              model: bme280,
      friendly name: air pressure

Los geht's, lesen wir unseren ersten Sensor-Wert über die Zephyr Sensor API aus.
Beginnen wir damit, wofür der Sensor BMP280 gemacht ist. Wir lesen den Kanal mit
dem **barometrischen Luftdruck** aus. Innerhalb der **Sensor API** ist das der
**Kanal** mit der englischen Abkürzung **press**.

-----------------------------------------------------------------------------

.. ..... ACTION .............................................................

.. image:: /_images/symbol-doing-vi.*
   :class: sidecar

.. compound::

   Den notwendigen Gerätenamen des Sensors hat uns die Info-Ausgabe zuvor
   geliefert, es ist ``bmp280@77``. Gib folgendes ein und beobachte::

      sensor get bmp280@77 press

-----------------------------------------------------------------------------

.. ..... RESULT .............................................................

.. image:: /_images/symbol-observe-or.*
   :class: sidecar

.. compound::

   :ign:`Folgendes wird (so ähnlich) erscheinen:`

   .. parsed-literal::
      :class: code

      channel idx=14 press shift=7 num_samples=1 value=1059494800000ns (98.335596)

Spiele nun einfach noch ein wenig mit dem Kommando :bcy:`sensor` herum. Versuche
doch mal die **Umgebungstemperatur** (:spelling:ignore:`engl.` *ambient
temperature*) oder gleich alle Kanäle zu lesen.

-----------------------------------------------------------------------------

.. ..... RESULT .............................................................

.. image:: /_images/symbol-observe-or.*
   :class: sidecar

.. compound::

   Hier unser Ergebnis:

   .. parsed-literal::
      :class: code

      channel idx=13 ambient_temp shift=5 num_samples=1 value=1872464000000ns (25.529999)

.. include:: yourspace.rsti

.. admonition:: Nur für Mentoren
   :class: red-border bug
   :collapsible:

   :download:`ZS-cytron_maker_pi_rp2040-usbcons-helloshell.uf2
   </_assets/ZS-cytron_maker_pi_rp2040-usbcons-helloshell.uf2>`,
   :download:`ZS-cytron_maker_pi_rp2040-usbcons-helloshell-bmp280.uf2
   </_assets/ZS-cytron_maker_pi_rp2040-usbcons-helloshell-bmp280.uf2>`,
   :download:`grove_i2c-bmp280@77.overlay
   </_assets/grove_i2c-bmp280@77.overlay>`
   – als Not-Backup gedacht!

.. [#] https://www.devicetree.org/specifications
.. [#] https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bmp280-ds001.pdf
.. [#] https://usb.org/sites/default/files/hut1_3_0.pdf

.. vi: ft=rst ai ts=3 et sw=3 sta
